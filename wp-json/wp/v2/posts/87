{"id":87,"date":"2014-09-11T14:25:02","date_gmt":"2014-09-11T21:25:02","guid":{"rendered":"http:\/\/www.codeapex.com\/?p=87"},"modified":"2016-12-30T14:07:04","modified_gmt":"2016-12-30T22:07:04","slug":"encrypting-data-on-a-linux-vps-luks-encrypted-volume-via-file-method","status":"publish","type":"post","link":"http:\/\/www.codeapex.com\/encrypting-data-on-a-linux-vps-luks-encrypted-volume-via-file-method\/","title":{"rendered":"Encrypting Data on a Linux VPS &#8211; LUKS Encrypted Volume via File Method"},"content":{"rendered":"<h2>Situation:<\/h2>\n<p>You wish to have certain files encrypted on your VPS and you do not want to repartition to accommodate an encrypted volume on a partition or logical volume.<\/p>\n<h2>Objective:<\/h2>\n<p>A mountable LUKS encrypted volume based on a file in the filesystem.<\/p>\n<h2>Plan + Execution:<\/h2>\n<h3>Install cryptsetup:<\/h3>\n<p>If cryptsetup is not installed already, use the appropriate command to install it for your distro.<\/p>\n<p>Debian based:<br \/>\n<code>apt-get install cryptsetup<\/code><\/p>\n<h3>Create Encrypted Volume File:<\/h3>\n<p>An empty non-sparse file is needed to serve as the encrypted volume. We will create such a file of 1G in size named enc-vol-1G at the root level directory, feel free to substitute your own size, name and location preferences for this file; the same goes for any arbitrary naming used here.<\/p>\n<p>Note we need a non-sparse file meaning the full 1G space has been allocated for the file by the filesystem, so we cannot just use the <code>touch<\/code> command to create the file; our options are either the <code>fallocate<\/code> or <code>dd<\/code> commands. For creating the file <code>fallocate<\/code> is faster but <code>dd<\/code> offers more features, prefilling the allocated space with pseudo-random data using <code>if=\/dev\/urandom<\/code> for instance.<\/p>\n<p><code>fallocate -l 1GB \/enc-vol-1G<\/code><br \/>\nor<br \/>\n<code>dd if=\/dev\/zero of=\/enc-vol-1G bs=1M count=1024<\/code><\/p>\n<h3>Transform File into a LUKS Partition with a Filesystem:<\/h3>\n<p>Turn the File Into a LUKS Partition:<br \/>\n<code>cryptsetup -y luksFormat \/enc-vol-1G<\/code><\/p>\n<p>Open the LUKS Partition and Setup Mapping Name:<br \/>\n<code>cryptsetup luksOpen \/enc-vol-1G encrypted_volume<\/code><\/p>\n<p>The mapping name is arbitrary and in our case we chose &#8220;encrypted_volume&#8221;. After running the command a new device is created: <code>\/dev\/mapper\/encrypted_volume<\/code> which we can treat in a similar manner as one would a disk partition.<\/p>\n<p>Create a Filesystem on the LUKS Partition:<br \/>\n<code>mke2fs -t ext4 \/dev\/mapper\/encrypted_volume<\/code><\/p>\n<p>Close the LUKS Partition Releasing the Mapping Name\u00a0 and Clearing Key from Kernel Memory:<br \/>\n<code>cryptsetup luksClose encrypted_volume<\/code><\/p>\n<p>Create a Mount Point:<br \/>\n<code>mkdir \/mnt\/secret_stuff<\/code><\/p>\n<p>Mount point name and location are arbitrary; customize per your needs.<\/p>\n<p>At this point our objective is met and we have a mountable LUKS encrypted volume based on a file in the filesystem.<\/p>\n<h3>How to use:<\/h3>\n<p>Opening the LUKS partition:<br \/>\n<code>cryptsetup luksOpen \/enc-vol-1G encrypted_volume<\/code><\/p>\n<p>Mounting the Encrypted Volume:<br \/>\n<code>mount \/dev\/mapper\/encrypted_volume \/mnt\/secret_stuff<\/code><\/p>\n<p>Anything you now copy to \/mnt\/secret_stuff will be encrypted.<\/p>\n<p>Examples:<br \/>\n<code>cp secret_file1.txt \/mnt\/secret_stuff<\/code><\/p>\n<p><code>cp -R secret_dir \/mnt\/secret_stuff<\/code><\/p>\n<p>Unmounting:<br \/>\n<code>umount \/mnt\/secret_stuff<\/code><\/p>\n<p>Closing the LUKS Partition:<br \/>\n<code>cryptsetup luksClose encrypted_volume<\/code><\/p>\n<h3>Notes on Security:<\/h3>\n<p>Remember this maxim: Physical Access = Root Access<\/p>\n<p>If someone has physical access to a machine they essentially can get root access.<\/p>\n<p>This is more crucial to note when using a VPS. Not only do the operators of the physical server hosting your VPS have &#8220;physical&#8221; access to your VPS but so does anyone who hacks the actual machine your VPS is on.<\/p>\n<p>While a LUKS partition is open the decryption key is stored in the kernel memory. A skilled person with root access can look for the key in memory or if they have &#8220;physical&#8221; access to the VPS they can just take a snapshot running state image of the VPS and pull the key from the snapshot.<\/p>\n<p>Essentially what this means is there is a small chance someone could get the encryption key for the encrypted volume while it is unlocked on the VPS.<\/p>\n<p>With that said a LUKS encrypted volume provides protection in the following scenarios assuming the LUKS partition is not currently open during them:<\/p>\n<ol>\n<li>The VPS itself is hacked by an intruder who gains root access. Even though the intruder has root access on the VPS they do not have the key to open the encrypted volume (<small>technically though if no one noticed the intrusion they could potentially leave some hidden process to patiently wait for the encrypted volume to be opened to grab the key then<\/small>).<\/li>\n<li>The physical server hosting the VPS is hacked by an intruder who copies all the data from the physical server offsite before getting found and blocked. This data includes all the data on your VPS&#8217;s hard disk (and RAM if an intruder took a snapshot of your running VPS) at the time the data was copied; but since the LUKS encrypted volume was closed at the time and the key not in your VPS&#8217;s RAM, the intruder will not be able to access the data in the encrypted volume in their copy of your VPS data.<\/li>\n<\/ol>\n<p>With that said data stored in a LUKS encrypted volume is more secure than otherwise due to the additional hurdles an intruder would have to navigate to even get a chance to access the data.<\/p>\n<h2>Misc Tips:<\/h2>\n<h3>Multiple Passphrases:<\/h3>\n<p>A LUKS device has 8 key slots that can be used for passphrases (or key files if one is inclined) to unlock it. Use the luksDump action of the cryptsetup command to to show the header information for the LUKS device and at the bottom will be information on the key slots.<\/p>\n<p><code>cryptsetup luksDump \/enc-vol-1G<\/code><\/p>\n<p>output snippet with key slot information:<\/p>\n<pre class=\"lang:default decode:true\">Key Slot 0: ENABLED\r\nIterations:             130398\r\nSalt:                   dc 66 3b 57 8b 70 29 d2 ad 36 78 6c 88 01 65 81\r\n98 df 17 7e 16 e6 76 46 d8 53 d7 40 ec a1 11 04\r\nKey material offset:    8\r\nAF stripes:             4000\r\nKey Slot 1: DISABLED\r\nKey Slot 2: DISABLED\r\nKey Slot 3: DISABLED\r\nKey Slot 4: DISABLED\r\nKey Slot 5: DISABLED\r\nKey Slot 6: DISABLED\r\nKey Slot 7: DISABLED<\/pre>\n<p>Key Slot 0 is currently being used for the passphrase we initially setup our LUKS device with. To add an additional passphrase:<\/p>\n<p><code>cryptsetup luksAddKey \/enc-vol-1G<\/code><\/p>\n<p>You will be first asked to enter any passphrase that unlocks the volume, then you will be prompted to enter a new additional passphrase that can be used to unlock the volume. The passphrase will use the next available key slot, alternatively to use a specific key slot for the passphrase (ex. using key slot 7): <code>cryptsetup --key-slot 7 luksAddKey \/enc-vol-1G<\/code><\/p>\n<p>To remove a passphrase use the luksRemoveKey action of the cryptsetup command:<\/p>\n<p><code>cryptsetup luksRemoveKey \/enc-vol-1G<\/code><\/p>\n<p>You will be prompted for the passphrase you want to remove. Alternatively to disable\/remove a specific key slot (ex. remove key slot 7): <code>cryptsetup luksKillSlot \/enc-vol-1G 7<\/code><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Situation: You wish to have certain files encrypted on your VPS and you do not want to repartition to accommodate an encrypted volume on a partition or logical volume. Objective: A mountable LUKS encrypted volume based on a file in the filesystem. Plan + Execution: Install cryptsetup: If cryptsetup is not installed already, use the [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"_genesis_hide_title":false,"_genesis_hide_breadcrumbs":false,"_genesis_hide_singular_image":false,"_genesis_hide_footer_widgets":false,"_genesis_custom_body_class":"","_genesis_custom_post_class":"","_genesis_layout":""},"categories":[1],"tags":[],"_links":{"self":[{"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/posts\/87"}],"collection":[{"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/comments?post=87"}],"version-history":[{"count":0,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/posts\/87\/revisions"}],"wp:attachment":[{"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/media?parent=87"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/categories?post=87"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/tags?post=87"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}
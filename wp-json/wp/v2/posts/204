{"id":204,"date":"2021-01-12T15:08:10","date_gmt":"2021-01-12T23:08:10","guid":{"rendered":"http:\/\/www.codeapex.com\/?p=204"},"modified":"2021-08-28T17:00:36","modified_gmt":"2021-08-29T00:00:36","slug":"increasing-linux-vps-ram-for-free-using-zram-udev-rule","status":"publish","type":"post","link":"http:\/\/www.codeapex.com\/increasing-linux-vps-ram-for-free-using-zram-udev-rule\/","title":{"rendered":"Increasing Linux VPS RAM for Free Using ZRAM &#8211; udev rule"},"content":{"rendered":"<h2>Situation:<\/h2>\n<p>You are reaching or exceeding the RAM limits of your Linux VPS.<\/p>\n<h2>Objective:<\/h2>\n<p>An increase in the amount of non-virtualized memory available to your applications on your VPS without resorting to paying for an upgraded VPS.<\/p>\n<h2>Plan + Execution:<\/h2>\n<p><!--more--><\/p>\n<p>Note we want an increase in the amount of fast physical memory available to our applications. Increasing virtualized memory (via an increase in swap partition or swap file sizes) would not meet our objective; though if your VPS is on SSDs then upping swap space may not be a bad option since solid state disks are substantially faster than traditional hard disks (but still not as fast as physical memory).<\/p>\n<p>One way of making more physical memory available to your applications is to be more efficient with the use of the RAM available. We can accomplish this by compressing data stored in memory; specifically we will use <a title=\"ZRAM Wikipedia\" href=\"http:\/\/en.wikipedia.org\/wiki\/Zram\" target=\"_blank\" rel=\"noopener\">ZRAM<\/a> to appropriate a percentage of total RAM as compressed block devices. Data stored in the area will be compressed and will take up less memory than if they weren&#8217;t.<\/p>\n<p>Realize though that ZRAM will put a little more load on the CPU since it now has to compress\/decompress data in that portion. So if you also reaching or exceeding the CPU limits of your VPS you should do testing to see if ZRAM helps your situation or perhaps consider actually upgrading your VPS.<\/p>\n<p>Note some commands listed below may require superuser priviledges. Either<\/p>\n<ol>\n<li>use the <code>su<\/code> command to change the login session&#8217;s owner to root; or<\/li>\n<li>prepend the commands with <code>sudo<\/code> (e.g. <code>sudo swapon -s<\/code>); or<\/li>\n<li>login as root directly<\/li>\n<\/ol>\n<h3>Checking Kernel Support:<\/h3>\n<p>In a terminal run this command:<br \/>\n<code>modprobe -nv zram<\/code><\/p>\n<p>If the result is a path to zram.ko then your kernel supports zram as a loadable module.<\/p>\n<h3>Checking if ZRAM is Already Enabled:<\/h3>\n<p>Some distributions come with ZRAM enabled by default (such as Lubuntu). Before continuing onward we should double check to ensure we are not trying to accomplish something that is already done.<br \/>\nCheck to see if the module is loaded:<br \/>\n<code>lsmod | grep zram<\/code><\/p>\n<p>If it is loaded (the result is a line starting with zram) check to see if the compressed block devices are setup and running as available swap devices:<br \/>\n<code>swapon -s<\/code><\/p>\n<p>If you see devices listed such as \/dev\/zram0, \/dev\/zram1,&#8230; then ZRAM is already running and there is nothing you need to do further.<\/p>\n<h3>Creating the udev rule<\/h3>\n<p>Enable the module:<br \/>\n\/etc\/modules-load.d\/zram.conf<br \/>\n<code>zram<\/code><\/p>\n<p>Configure the number of \/dev\/zram nodes you need.<br \/>\n\/etc\/modprobe.d\/zram.conf<br \/>\n<code>options zram num_devices=2<\/code><\/p>\n<p>Create the udev rule as shown in the example.<br \/>\n\/etc\/udev\/rules.d\/99-zram.rules<br \/>\n<code>KERNEL==\"zram0\", ATTR{disksize}=\"512M\" RUN=\"\/sbin\/mkswap \/dev\/zram0\", TAG+=\"systemd\"<br \/>\nKERNEL==\"zram1\", ATTR{disksize}=\"512M\" RUN=\"\/sbin\/mkswap \/dev\/zram1\", TAG+=\"systemd\"<\/code><\/p>\n<p>Add \/dev\/zram to your fstab.<br \/>\n\/etc\/fstab<br \/>\n<code>\/dev\/zram0 none swap sw 0 0<br \/>\n\/dev\/zram1 none swap sw 0 0<\/code><\/p>\n<p>As for how large should the zram devices be in total depends on the kind of workload, note the following comment from one of ZRAM&#8217;s developers (back when it was known as Compcache): <a title=\"ZRAM (Compcache) Nitin Gupta Comment\" href=\"https:\/\/code.google.com\/p\/compcache\/wiki\/CompilingAndUsingNew\">https:\/\/code.google.com\/p\/compcache\/wiki\/CompilingAndUsingNew<\/a><\/p>\n<blockquote><p><span class=\"author\">Comment by project member <a class=\"userlink\" href=\"https:\/\/code.google.com\/u\/nitingupta910@gmail.com\/\">nitingupta910@gmail.com<\/a>, <\/span> <span class=\"date\" title=\"Fri May 7 01:35:52 2010\">May 7, 2010<\/span><\/p>\n<p>@Paczesiowa: ramzswap should not be given so much of memory as its just a (virtual) swap device &#8212; it can compress only anonymous (say, process stack, heap etc.) memory. There are also other kinds of caches in the system, say filesystem cache which also require lot of memory. So, to have a good balance among all the different caches, ramzswap should not be given nearly 100% of RAM.<\/p>\n<p>Appropriate amount of ramzswap memory depends on kind of workload. For typical desktop workloads, I found 25% to work just fine (this is the default).<\/p><\/blockquote>\n<h3>Reboot:<\/h3>\n<p>Reboot.<\/p>\n<h3>Verify:<\/h3>\n<p>Verify that the module is loaded:<br \/>\n<code>lsmod | grep zram<\/code><\/p>\n<p>If the result is a line starting with zram then it is loaded.<\/p>\n<p>Verify that the compressed block devices are setup and running as available swap devices:<br \/>\n<code>swapon -s<\/code><\/p>\n<p>If you see devices listed such as \/dev\/zram0, \/dev\/zram1,&#8230; then the compressed block devices are enabled as swap devices and the setup of ZRAM is complete.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Situation: You are reaching or exceeding the RAM limits of your Linux VPS. Objective: An increase in the amount of non-virtualized memory available to your applications on your VPS without resorting to paying for an upgraded VPS. Plan + Execution:<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"_genesis_hide_title":false,"_genesis_hide_breadcrumbs":false,"_genesis_hide_singular_image":false,"_genesis_hide_footer_widgets":false,"_genesis_custom_body_class":"","_genesis_custom_post_class":"","_genesis_layout":""},"categories":[1],"tags":[],"_links":{"self":[{"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/posts\/204"}],"collection":[{"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/comments?post=204"}],"version-history":[{"count":4,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/posts\/204\/revisions"}],"predecessor-version":[{"id":275,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/posts\/204\/revisions\/275"}],"wp:attachment":[{"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/media?parent=204"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/categories?post=204"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/www.codeapex.com\/wp-json\/wp\/v2\/tags?post=204"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}